#!/usr/bin/env python3
import sys
from pathlib import Path

def make_raw_literal(text: str) -> str:
    """Wrap text in a C++ raw string literal with a unique delimiter.
    Using a raw string avoids any need to escape quotes/backslashes and
    prevents accidental chunk boundary issues.
    """
    # Choose a delimiter unlikely to appear in license texts
    delim = "__IFR1_LICENSE__"
    return f'R"{delim}({text}){delim}"'

def main():
    if len(sys.argv) < 3:
        print("Usage: embed_text.py <input_text_1> [input_text_2 ...] <output_header>")
        return 2

    out_path = Path(sys.argv[-1])
    in_paths = [Path(p) for p in sys.argv[1:-1]]

    full_text = ""
    for in_path in in_paths:
        if not in_path.exists():
            print(f"Input not found: {in_path}")
            return 4
        
        content = in_path.read_text(encoding='utf-8')
        if full_text:
            if not full_text.endswith('\n\n'):
                if full_text.endswith('\n'):
                    full_text += '\n'
                else:
                    full_text += '\n\n'
        full_text += content

    size = len(full_text.encode('utf-8'))
    raw = make_raw_literal(full_text)

    out_path.parent.mkdir(parents=True, exist_ok=True)
    with open(out_path, 'w', encoding='utf-8') as f:
        f.write('// Auto-generated by tools/embed_text.py. Do not edit.\n')
        f.write('#pragma once\n')
        f.write('extern const unsigned int g_license_size;\n')
        f.write('extern const char g_license_text[];\n')
        f.write('\n')
        f.write('#ifdef RESOURCES_EMBED_IMPL\n')
        f.write(f'const unsigned int g_license_size = {size};\n')
        # Emit as a single raw string literal to avoid escaping/splitting pitfalls
        f.write(f'const char g_license_text[] = {raw};\n')
        f.write('#endif // RESOURCES_EMBED_IMPL\n')

    return 0

if __name__ == '__main__':
    sys.exit(main())
